# 211117_TIL

# 1. 스코프(Scope)란 무엇인가

프로그래밍 언어의 기본 패러다임 중 하나는 변수에 값을 저장하고 저장된 값을 가져다 쓰고 수정하는 것이다. 이 기능은 프로그램에서 상태를 나타낼 수 있게 해준다. 이와 같은 개념이 없다면 프로그램은 상당히 제한적이고 지극히 심심한 작업만 할 수 있을 것이다. 그러나 변수를 프로그램에 추가하면 다음과 같은 재미있는 질문이 생긴다.

- 변수는 어디에 살아있는가? 다른 말로 하면 변수는 어디에 저장되는가?
- 필요할 때 프로그램은 어떻게 변수를 찾는가?

이 질문을 통해 알 수 있는 것은 특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데는 잘 정의된 규칙이 필요하다는 점이다. 바로 이런 규칙을 '스코프(Scope)'라 한다.

그렇다면 스코프 규칙은 어디서 어떻게 정의될까?

## 1-1. 컴파일러 이론

여러 언어를 다루어봤다면 자명할 수도 있겠고 아니라면 놀라울 수도 있겠지만, 자바스크립트는 일반적으로 '동적' 또는 '인터프리터' 언어로 분류하나 사실은 '컴파일러 언어'다. 물론 자바스크립트가 전통적인 많은 컴파일러 언어처럼 코드를 미리 컴파일하거나 컴파일한 결과를 분산 시스템을 이용할 수 있는 것은 아니다. 하지만 자바스크립트 엔진은 전통적인 컴파일러 언어에서 컴파일러가 하는 일의 상당 부분을 우리가 아는 것보다 세련된 방식으로 처리한다.

전통적인 컴파일러 언어의 처리 과정에서는 프로그램을 이루는 소스 코드가 실행되기 전에 보통 3단계를 거치는데, 이를 '컴파일레이션(Compilation)'이라고 한다.

### 1) 토크나이징(Tokenizing) / 렉싱(Lexing)

문자열을 나누어 '토큰(Token)'이라 불리는 의미 있는 조각으로 만드는 과정이다. 예를 들어, "var a = 2;"라는 프로그램을 보자. 이 프로그램은 다음의 토큰으로 나눌 수 있다.

- var
- a
- =
- 2
- ;

빈칸은 하나의 토큰으로 남을 수도 있고 아닐 수도 있다. 이는 빈칸이 의미가 있느냐, 없느냐에 달렸다. 

### 2) 파싱(Parsing)

토큰 배열을 프로그램의 문법 구조를 반영하여 중첩 원소를 갖는 트리 형태로 바꾸는 과정이다. 파싱의 결과로 만들어진 트리를 AST(Abstract Syntax Tree), 추상 구문 트리라 부른다.

"var a = 2;"의 트리는 먼저 변수 선언(Variable Declaration)이라 부르는 최상위 노드에서 시작하고, 최상위 노드는 'a'의 값을 가지는 확인자(Identifier)와 대입 수식(Assignment Expression)이라 부르는 자식 노드를 가진다. 대입 수식 노드는 '2'라는 값을 가지는 숫자 리터럴(Numeric Literal)을 자식 노드로 가진다.

### 3) 코드 생성(Code-Generation)

AST를 컴퓨터에서 실행 코드로 바꾸는 과정이다. 이 부분은 언어에 따라 또는 목표하는 플랫폼에 따라 크게 달라진다. 코드 생성에 대한 세부 사항을 보며 끙끙대기보다는 일단 앞서 말한 "var a = 2;"를 나타내는 AST를 기계어 집합으로 바꾸어 실제로 'a'라는 변수를 생성하고 값을 저장할 방법이 있다고 치자.

자바스크립트 엔진은 이 세가지 단계 뿐 아니라 많은 부분에서 다른 프로그래밍 언어의 컴파일러보다 훨씬 복잡하다. 예컨대, 자바스크립트 엔진은 파싱과 코드 생성 과정에서 불필요한 요소를 삭제하는 과정을 거쳐 실행 시 성능을 최적화한다.

자바스크립트 엔진이 기존 컴파일러와 다른 점은 자바스크립트 컴파일레이션을 미리 수행하지 않아서 최적화할 시간이 많지 않다는 것이다.

자바스크립트 컴파일레이션은 보통 코드가 실행되기 겨우 수백만 분의 일초 전에 수행한다. 자바스크립트 엔진은 가능한 한 가장 빠른 성능을 내기 위해 여러 종류의 트릭을 사용한다. (레이지 컴파일이나 핫 리컴파일 같은 JITs)

간단히 말하자면, 어떤 자바스크립트 조각이라도 실행되려면 먼저 컴파일되어야 한다는 것이다. 즉, 자바스크립트 컴파일러는 프로그램 "var a = 2;"를 받아 컴파일하여 바로 실행될 수 있게 한다.

## 1-2. 스코프 이해하기

### 1-2-2. 앞과 뒤

프로그램 "var a = 2;"를 보면 하나의 구문으로 보인다. 그러나 우리의 새로운 친구 엔진은 그렇게 보지 않는다. 사실 엔진은 두 개의 서로 다른 구문으로 본다. 하나는 컴파일러가 컴파일레이션 과정에서 처리할 구문이고, 다른 하나는 실행 과정에서 엔진이 처리할 구문이다.

그럼 이제 엔진과 친구들이 프로그램 "var a = 2;"에 어떻게 접근하는지 낱낱이 살펴보자.

이 프로그램에서 컴파일러가 할 첫 번째 일은 렉싱을 통해 구문을 토큰으로 쪼개는 것이다. 그 후 토큰을 파싱해 트리 구조를 만든다. 그러나 코드 생성 과정에 들어가면 컴파일러는 몇몇 독자의 추측과는 다르게 프로그램을 처리한다.

컴파일러가 다음 의사 코드(Pseudo-Code)로 요약될 수 있는 코드를 생성한다고 생각할 수 있다.

하지만, 이는 그리 정확한 설명이 아니다. 컴파일러는 다음 일을 진행한다.

- 컴파일러가 'var a'를 만나면 스코프에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나가고, 그렇지 않으면 컴파일러는 새로운 변수 a를 스코프 컬렉션 내에 선언하라고 요청한다.
- 그 후 컴파일러는 'a = 2' 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인한다. 가능하다면 엔진은 변수 a를 사용하고, 아니라면 엔진은 다른 곳을 살핀다.

엔진이 마침내 변수를 찾으면 변수에 값 2를 넣고, 못 찾는다면 엔진은 손을 들고 에러가 발생했다고 할 것이다. 요약하면, 별개의 두 가지 동작을 취하여 변수 대입문을 처리한다. 첫째, 컴파일러가 변수를 선언한다. 둘째, 엔진이 스코프에서 변수를 찾고 변수가 있다면 값을 대입한다.

### 1-2-3. 컴파일러체

더 나아가기 전에 컴파일러 관련 용어를 약간 더 살펴보자.

2단계에서 컴파일러가 생성한 코드를 실행할 때 엔진은 변수 a가 선언된 적이 있는지 스코프에서 검색한다. 이때 엔진이 어떤 종류의 검색을 하느냐에 따라 검색을 하느냐에 따라 검색 결과가 달라진다. 앞의 경우에서 엔진은 변수 a를 찾기 위해 LHS 검색을 수행한다. 다른 종류의 검색은 RHS라 부른다. 여기서 'L'과 'R'이 무엇을 뜻하는지 예상할 수 있을 것이다. L과 R은 각각 '왼쪽 방향(Left-Hand Side)'과 '오른쪽 방향(Right-Hand Side)'을 뜻한다.

여기서 방향이란 대입 연산의 방향을 말한다.

다른 말로 하면 LHS 검색은 변수가 대입 연산자의 왼쪽에 있을 때 수행하고, RHS 검색은 변수가 대입 연산자의 오른쪽에 있을 때 수행한다.

좀 더 엄밀하게 살펴보자. RHS 검색은 단순히 특정 변수의 값을 찾는 것과 다를 바 없다. 반면, LHS 검색은 값을 넣어야 하므로 변수 컨테이너 자체를 찾는다. 따라서 정확히 말하면 RHS는 그 자체로는 '대입문의 오른쪽'이 아니다. 좀 더 정확히 말하면 RHS는 '왼편이 아닌 쪽'에 가깝다.

```jsx
console.log(a);
```

a에 대한 참조는 RHS 참조다. 구문에서 a에 아무것도 대입하지 않기 때문이다. 대신 a의 값을 가져와 console.log()에 넘겨준다. 다른 예제를 보자.

```jsx
a = 2;
```

a에 대한 참조는 LHS 참조다. 현재 a 값을 신경 쓸 필요 없이 '= 2' 대입 연산을 수행할 대상 변수를 찾기 때문이다.

LHS와 RHS 참조를 모두 수행하는 다음 프로그램을 보자.

```jsx
function foo(a) {
	console.log(a);  // 2
}
foo(2);
```

마지막 줄에서 foo() 함수를 호출하는 데 RHS 참조를 사용한다. 즉 "가서 foo의 값을 찾아 내게 가져와라"라는 뜻이다. 여기서 ()는 실행된다는 뜻이므로 foo는 함수여야 한다.

이 부분에 미묘하지만 중요한 대입이 수행된다. 무엇을 가리키는지 알겠는가?

앞의 코드 속에 내재된 'a = 2'를 놓쳤을지도 모르겠다. 인수로 값 2를 함수 foo()에 넘겨줄 때 값 2를 인자 a에 대입하는 연산이 일어난다. 이 인자 a에 대한 대입 연산을 위해 LHS 검색이 수행된다.

변수 a에 대한 RHS 참조 역시 수행되는데, 그 결괏값은 console.log() 함수에 넘겨진다. 또 console.log()가 실행되려면 참조가 필요하다. console 객체를 RHS 검색하여 log 메서드가 있는지 확인한다.

마지막으로 값 2를 RHS로 불러온 변수 a를 통해 log()에 넘겨주는 과정에서 LHS/RHS를 주고받는 작업에 대한 개념을 짚어보자. 구현된 log()의 내부에는 인자가 있을 것이고, 첫번째 인자를 LHS 검색으로 찾아 2를 대입할 것이다.

### 1-2-4. 엔진과 스코프의 대화

다음 코드의 실행 과정을 대화라고 상상해보자. 그 대화는 이럴 것이다.

```jsx
function foo(a) {
	console.log(a);  // 2
}
foo(2);
```

- 엔진    : 안녕, 스코프. foo에 대한 RHS 참조가 필요해. foo라고 들어본 적 있니?
- 스코프 : 응, 들어봤어. 컴파일러가 좀 전에 선언하더라고. foo는 함수야. 이걸 보면 돼.
- 엔진    : 좋아. 고마워. 자, 이제 나는 foo를 실행해야겠어.
- 엔진    : 이봐, 스코프. a에 대한 LHS 참조도 구해야 하는데, 들어본 적 있어?
- 스코프 : 물론이지. 컴파일러가 a를 foo의 인자로 좀 전에 선언했어. 이걸 봐.
- 엔진    : 항상 도와줘서 고마워, 스코프. 정말 고마워. 이제 2를 a에 대입할 시간이야.
- 엔진    : 스코프, 자꾸 귀찮게 해서 미안해. console에 대한 RHS 검색이 필요해. 해줄 수 있겠니?
- 스코프 : 문제없어, 엔진. 이게 내가 항상 하는 일이잖니. 자, console을 찾았어. 내장되어 있더라. 이거야.
- 엔진    : 완벽해. 이제 log()를 찾아볼까. 좋아 멋져, 이건 함수구나.
- 엔진    : 요~ 스코프! a의 RHS 참조 찾는 것 좀 도와줄 수 있을까? 나한테도 있긴 할테지만, 확실히 해두고 싶어.
- 스코프 : 옳은 말이야, 엔진. 변함없이 엄밀하는구나. 여기 있어.
- 엔진    : 멋져. 이제 a의 값을... 값은 2구나. log()에 넘기자.

### 1-2-5. 퀴즈

지금까지 배운 것을 확인해보자. 다음 코드의 실행 과정을 엔진의 역할을 맡아서 스코프와 대화해보자.

```jsx
function foo(a) {
	var b = a;
	return a + b;
}

var c = foo(2);
```

1) 모든 LHS 검색을 찾아보자.

2) 모든 RHS 검색을 찾아보자.